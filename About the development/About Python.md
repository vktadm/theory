Язык Python назван в **честь комик-группы Монти Пайтон** а не в честь змеи. Создатель языка **Гвидо Ван Россум**.

**PEP** – Python Enhancement Proposals. **PEP-8** – набор правил как стоит писать код.

**PEP — Python Enhancement Proposal**, предложения по развитию Python. Эти стандарты позволяют создавать унифицированную проектную документацию для новых утвержденных возможностей языка Python. 

Самый известный PEP имеет восьмой порядковый номер. [PEP8](https://pep8.org/) содержит перечень принципов написания красивого и лаконичного программного кода на языке Python.

**В Python все является объектами**, включая встроенные типы данных (строки, числа, списки и т.д.), функции и даже классы. Это означает, что вы можете передавать объекты как аргументы функций, возвращать их из функций и присваивать переменным.

## Запись в память / выделение ресурсов для объекта

1. **Запуск интерпретатора**
Когда запускается Python-программа, операционная система создает новый процесс и выделяет для него виртуальное адресное пространство. В это пространство загружается интерпретатор Python и необходимые ему данные.

2. **Аллокация памяти**
Python использует специальный механизм, называемый **менеджером памяти**, для управления памятью. Этот менеджер отвечает за выделение памяти для объектов и освобождение неиспользуемой памяти. Аллокация может происходить на двух уровнях:
- **На уровне операционной системы**: Для больших объектов (обычно более 512 байт) запросы отправляются в системный аллокатор, такой как `malloc`.
- **На уровне интерпретатора**: Для небольших объектов Python использует свои оптимизированные механизмы, чтобы уменьшить накладные расходы при выделении памяти.

3. **Создание объектов**
При создании нового объекта Python проверяет, достаточно ли свободной памяти. Если пороговое значение для текущего поколения объектов превышено, инициируется процесс **сборки мусора** (garbage collection), который освобождает память от неиспользуемых объектов.

4. **Управление памятью**
Python использует счетчики ссылок для отслеживания количества ссылок на объекты. Когда счетчик ссылок объекта достигает нуля, объект считается неиспользуемым и может быть удален из памяти.

5. **Виртуальная память**
Python работает с виртуальной памятью, что позволяет ему абстрагироваться от физической памяти компьютера. Это означает, что Python управляет памятью через виртуальные адреса, которые затем сопоставляются с реальными адресами физической памяти операционной системой.
## Управления памятью / сборка мусора

**Время жизни переменной** в Python — это период, в течение которого переменная находится в памяти.

**Время жизни переменной внутри функции** длится до тех пор, пока функция выполняется. Переменные «уничтожаются», когда выходят из функции. Это значит, что функция не помнит значения переменных из предыдущих вызовов. 

**Переменные, объявленные вне функции**, будут видны внутри неё. У них глобальная область видимости. Если переменная определена вне функции, то внутри функции можно прочитать её значение, но нельзя изменить. Чтобы изменить значение, нужно объявить переменную как глобальную с помощью ключевого слова **global**.

Каждый объект в Python — это, в первую очередь, объект, унаследованный от базового класса **`PyObject`**.

`PyObject` содержит всего два поля: `ob_refcnt` — количество ссылок, и `ob_type` — указатель на другой объект, тип данного объекта.

**GIL** — Global Interpreter Lock - **глобальная блокировка интерпретатора** - это механизм в Python, который обеспечивает безопасность потоков, позволяя только одному потоку выполнять байт-код Python в любой момент времени. Это означает, что даже если у вас есть многопоточное приложение, в каждый момент времени только один поток может выполнять код Python, а остальные потоки будут ждать своей очереди.

**Garbage Collection** (сборка мусора), — это механизм управления памятью в Python, который автоматически освобождает память, занятую объектами, на которые больше нет ссылок. Это позволяет разработчикам не заботиться о ручном управлении памятью, что снижает риск утечек памяти и упрощает разработку.
##### Как работает сборка мусора в Python?

1. **Подсчет ссылок**: Каждый объект в Python имеет счетчик ссылок, который увеличивается, когда на него создается новая ссылка, и уменьшается, когда ссылка удаляется. Когда счетчик ссылок объекта достигает нуля, объект считается "мусором" и может быть удален.
2. **Циклические ссылки**: Подсчет ссылок не может обнаружить циклические ссылки (когда два или более объектов ссылаются друг на друга). Для этого в Python используется дополнительный механизм — **поколенческий сборщик мусора** (generational garbage collector).
3. **Поколения объектов**: Все объекты делятся на три поколения:
    - **Первое поколение**: Новые объекты.
    - **Второе поколение**: Объекты, которые пережили одну сборку мусора.
    - **Третье поколение**: Долговременные объекты.
Cборка мусора запускается чаще для объектов первого поколения и реже для старших поколений, так как ожидается, что новые объекты имеют короткий срок жизни.
4. **Запуск сборщика**: Сборщик мусора запускается автоматически при определенных условиях (например, когда создается новый контейнерный объект) или может быть вызван вручную с помощью функции `gc.collect()`.

**Зачем это нужно?**
Сборка мусора упрощает управление памятью и помогает избежать утечек памяти, позволяя разработчикам сосредоточиться на логике приложения вместо управления ресурсами. Однако стоит помнить, что сборка мусора может вызывать небольшие задержки в работе программы из-за необходимости освобождения памяти. Таким образом, GC является важной частью Python, обеспечивая автоматическое управление памятью и повышая удобство разработки.

## Python - интерпретируемый ЯП

**Компилируемые** языки сразу переводятся **в машинный код**, который может выполнить процессор. Формируется исполняемый файл. В результате они выполняются быстрее и эффективнее, чем интерпретируемые языки. Кроме того, в таких языках разработчик лучше контролирует аппаратные средства (управление памятью, использование ЦП и т.д.).

Компилируемым языкам требуется **дополнительный этап «сборки»**, при котором их сначала компилируют вручную. Каждый раз при внесении изменений вам нужно будет «пересобирать» программу. 

Примеры **истинных компилируемых языков**: C/C++, Rust и Go.

**Интерпретатор** — это программа, которая выполняет код, написанный на языке программирования, построчно.

**Интерпретируемые языки гораздо медленнее компилируемых**.

Интерпретируемые языки более гибкие и чаще предлагают такие возможности, как динамическая типизация и меньший размер программы. Кроме того, исходный **код программы выполняют интерпретаторы, поэтому сам код не зависит от платформы**.

Примеры **интерпретируемых языков**: PHP, Ruby, Python и JavaScript.

**JIT-компиляция** - **Just-In-Time компиляция**, — это метод, который позволяет преобразовывать байт-код или исходный код в машинный код непосредственно во время выполнения программы. Это делается для повышения производительности и оптимизации работы программного обеспечения.

## Императивные и декларируемые ЯП

В **императивном языке** программист будет указывать последовательность команд для выполнения (это все языки программирования которые мы считаем «языками программирования»).

**Декларативные** же языки в свою очередь ожидают от нас описания результата, который мы хотим получить в ходе выполнения запроса. Яркий пример декларативного языка это SQL (Stucted Query Language) или же структурированный язык запросов.

Декларативными языками еще называют HTML, CSS, SVG, VRML, SQL, lex/VACC.

## Динамическая и статическая типизация

**Динамическая типизация** предполагает, что в процессе выполнения команды переменная может содержать объекты различных типов. То есть мы объявляем переменную не указывая явно, какой тип данных в ней будет содержаться, и в процессе выполнения программы в одной переменной может побывать как текст так и число, а может и булево значение.

**Статическая типизация** предполагает, что при задании переменной сразу указывается тип данных, который она может содержать.

## Особенности Python

##### Интроспекция
Способность программы получать различную информацию об объектах во время работы программы. Если конкретно, то вы можете узнать какому классу принадлежит объект, с каким типом данных вы работаете в данный момент или список атрибутов и методов, доступных для указанного объекта.

**Примеры полезных функций интроспекции в Python:**
```python
dir() # Получить список атрибутов и методов объекта.

type() # Определить типа объекта.

hasattr(object, name) # проверить наличие определенного атрибута у объекта. Возвращаект True или False.

# object - объект, у которого проверяется наличие атрибута.
# name - строка, представляющая имя атрибута, который нужно проверить.

id() # Возвращает уникальный идентификатор (целое число) для заданного объекта. 
# Этот идентификатор представляет собой адрес объекта в памяти и остается постоянным на протяжении всего его существования.

isinstance(object, classinfo) # Проверяет, является ли объект экземпляром указанного класса или его подкласса.

# object - объект, который необходимо проверить.
# classinfo - класс, тип или кортеж классов/типов, с которыми нужно сравнить объект.

text = "Hello" 
print(isinstance(text, str)) # Вывод: True
```
##### Мультиплатформенность
##### Встроенные паттерны проектирования

В Python существуют свои встроенные паттерны проектирования, лучшим примером для понимания служат **декоратор и итератор**.

Декоратор позволяет расширять функциональность без наследования.
##### Обширный набор стандартных библиотек

При использовании Core Python вы получаете «в коробке» большой набор полезных стандартных библиотек. Примером может служить библиотека для работы с БД **SQLite**, а также **json, math, re, random, csv, html** и много других.
