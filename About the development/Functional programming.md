Когда говорят о ФП, прежде всего имеют в виду следующее:

- Функции – это «_граждане_ _более высокого сорта_», т.е., все, что можно делать с «данными», можно делать и с функциями (в том числе передача функции другой функции в качестве аргумента).
    
- Использование _рекурсии_ в качестве основной структуры контроля потока управления. В некоторых языках не существует иной конструкции цикла, кроме рекурсии.
    
- Акцент на _обработке последовательностей_. Списки с рекурсивным обходом подсписков часто используются в качестве замены циклов.
    
- «Чистые» функциональные языки избегают побочных эффектов. Это _исключает присваивания_, почти повсеместно распространенный в императивных языках подход, при котором за одной и той же переменной последовательно закрепляются разные значения для отслеживания состояния программы.
    
- ФП не одобряет или совершенно запрещает инструкции, используя вместо этого _вычисление выражений_ (т.е. функций с аргументами). В предельном случае, одна программа есть одно выражение (плюс дополнительные определения).
    
- ФП акцентируется на том, _что_ должно быть вычислено, а не _как_.

**Pure function** - это функции, которые принимают аргументы и возвращают конкретное значение (или значения). Эти функции не изменяют свои входные аргументы и не изменяют состояние программы. Они просто предоставляют результат данного вычисления.

В программировании (и в математике) функциями **высшего порядка** называются функции, которые выполняют одно (или оба) из этих действий:
1. Принимают одну (и более) функций в качестве аргументов.
2. Возвращают функцию в качестве результата.
Все остальные функции считаются функциями **первого порядка**.

Теоретически программы, построенные с использованием функционального стиля, проще:
- **Разрабатывать,** потому что вы можете кодировать и использовать каждую функцию изолированно
- **Отлаживать и тестировать,** потому что вы можете тестировать и отлаживать отдельные функции, не глядя на остальную часть программы
- **Понимать**, потому что вам не нужно иметь дело с изменениями состояния на протяжении всей программы

По словам **Гвидо ван Россума** (голландский программист, прежде всего известный как автор языка программирования Python), на Python в большей степени влияют императивные языки программирования, чем функциональные языки.
#### Оператор lambda

Лямбда-функции в Python являются **анонимными**. Это означает, что функция безымянна. Как известно, ключевое слов `def` используется в Python для определения обычной функции.

В Python имеется возможность создавать короткие однострочные функции с использованием оператора `lambda`, которые называются **лямбда-функциям**. Вот общий формат определения лямбда-функции: `lambda список_аргументов: выражение`
```python
lambda_function = lambda x, y: x + y

lambda_function(5,7)
# >> 12
func = lambda_function
func(3,4)
# >> 7
dic = {'функция1': lambda_function}
dic['функция1'](7,8)
# >> 15
```
#### Функция map

Встроенная в Python функция `map` – это функция более высокого порядка, которая предназначена для выполнения именно такой задачи. Она позволяет обрабатывать одну или несколько последовательностей с использованием заданной функции. Вот общий формат функции `map`: `map(функция, последовательности)`

В данном формате **функци** – это ссылка на стандартную функцию либо лямбда-функция, и **последовательность** – это одна или несколько отделенных запятыми итерируемых последовательностей, т.е. списки, кортежи, диапазоны или строковые данные.
```python
seq = (1, 2, 3, 4, 5, 6, 7, 8, 9)
seq2 = (5, 6, 7, 8, 9, 0, 3, 2, 1)

lambda_function = lambda x, y: x + y

result = map(lambda_function, seq, seq2)
result
# >> <map object at 0x000002897F7C5B38>
list(result)
# >> [6, 8, 10, 12, 14, 6, 10, 10, 10]
```
#### Функция filter

 В результирующем списке будут только те значения, для которых значение функции для элемента последовательности истинно. Вот общий формат функции `filter`: `filter(предикативная_функция, последовательность)`.
 
 Предикативная функция – это ссылка на стандартную функцию либо лямбда-функция, которая возвращает истину либо ложь, и _последовательность_ – это итерируемая последовательность, т.е. список, кортеж, диапазон или строковые данные.
```python
is_even = lambda x: x % 2 == 0
seq = (1, 2, 3, 4, 5, 6, 7, 8, 9)

filtered = filter(is_even, seq)
list(filtered)
# >> [2, 4, 6, 8]
```
**Примечание**. Для предотвращения выхода за пределы ленивой последовательности необходимо отслеживать возникновение ошибки StopIteration. Например,
```python
seq = sequence

try:    
	total = next(seq)
except StopIteration:
	return
```
##### Функция reduce

Общий формат функции `reduce`: `reduce(функция, последовательность, инициализатор)`

_Функция_ – это ссылка на редуцирующую функцию; ею может быть стандартная функция либо лямбда-функция, _последовательность_ – это итерируемая последовательность, т.е. список, кортеж, диапазон или строковые данные, и _инициализатор_ – это параметрическая переменная, которая получает начальное значение для накопителя.
```python
seq = (1, 2, 3, 4, 5, 6, 7, 8, 9)
get_sum = lambda a, b: a + b
summed_numbers = reduce(get_sum, seq)
# >> 45
```

```python
sentences = ["Варкалось.",
			 "Хливкие шорьки пырялись по наве, и",
			 "хрюкотали зелюки, как мюмзики в мове."]
			 
wsum = lambda aсс, sentence: aсс + len(sentence.split())
number_of_words = reduce(wsum, sentences, 0)
number_of_words
# >> 13
```
##### Функция zip

Встроенная функция `zip` объединяет отдельные элементы из каждой последовательности в кортежи, т.е. она возвращает итерируемую последовательность, состоящую из кортежей. Вот общий формат функции `zip`: `zip(последовательность, последовательность, ...)`
```python
x = 'абв'
y = 'эюя'

zipped = zip(x, y)
list(zipped)
# >> [('а', 'э'), ('б', 'ю'), ('в', 'я')]
```

В сочетании с оператором `*` эта функция используется для распаковки объединенной последовательности (в виде пар, троек и т.д.) в отдельные кортежи. Приведенный ниже интерактивный сеанс это демонстрирует:
```python
x2, y2 = zip(*zip(x, y))

x2
# >> ('а', 'б', 'в')
y2
# >> ('э', 'ю', 'я')

x == ''.join(x2) and y == ''.join(y2)
# >> True
```
##### Функция enumerate
Встроенная функция enumerate возвращает индекс элемента и сам элемент последовательности в качестве кортежа. Вот общий формат функции enumerate: `enumerate(последовательность)`

В данном формате _последовательность_ – это итерируемая последовательность, т.е. список, кортеж, диапазон или строковые данные. Функция enumerate возвращает ленивый объект-последовательность, который нужно вычислить, чтобы увидеть результат.
```python
lazy = enumerate(['а','б','в'])

list(lazy)
# >> [(0, 'а'), (1, 'б'), (2, 'в')]
```

```python
convert = lambda tup: tup[1].upper() + str(tup[0])
lazy = map(convert, enumerate(['а','б','в']))

list(lazy)
# >> ['А0', 'Б1', 'В2']
```


## Что делает функции нечистыми?

- Глобальные мутации, т.е. внесение изменений в глобальное состояние
```python
def append_one(xs):
	xs.append(1)
	return xs

xs = []
print(append_one(xs))
# Результат: [1]
print(append_one(xs))
# Результат: [1, 1]
```

- Недетерминированность функций, т.е. которые для одинаковых входных значений могут возвращать разные результаты
```python
import randomprint(random.random())

# Результат: 0.2334551699781765
print(random.random())
# Результат: 0.7073046734532323
```

- Операции ввода-вывода
```python
with open('temp.txt', 'w') as f:
	f.write('Hello!')
	
with open('temp.txt', 'r') as f:
	print(f.read())
# Результат: Hello!

with open('temp.txt', 'w') as f:
	f.write('Hi!')
with open('temp.txt', 'r') as f:
	print(f.read())  	
# Результат: Hi!
```

Из чистых функций вытекает **ссылочная (референциальная) прозрачность**. Говорят, что программа или математическое выражение ссылочно прозрачны, если любое подвыражение можно заменить его значением, и это не приведет к изменению значения целого, т. е. скрытые побочные эффекты отсутствуют.

**Ссылочная прозрачность**:
1. **улучшает тестопригодность программ**, т.е. поведение подпрограмм не зависит от контекста, повторный запуск приложения дает одинаковый результаты как следствие отсутствия мутаций
2. **обеспечивается модульность**, т.е. поведение функций не зависит от контекста, и чистые функции можно легко составлять в композиции, строя новые формы поведений
3. **упрощает обеспечение конкурентности** из-за отсутствия необходимости в синхронизации, т.к. отсутствие совместных мутируемых данных делает синхронизацию ненужной.

**Главный недостаток состоит в том, что язык Python, как таковой, не является языком функционального программирования.**

В отличие от объектно-ориентированного программирования, которое строит сложные формы поведения с помощью наследования, ФП опирается на _композицию функций_. Этот принцип перекликается с философией Unix, состоящей из 2 правил:

- _Правило композиции_ - строить программы так, чтобы иметь возможность легко их соединять с другими программами.
    
- _Правило модульности_ - писать простые части, которые можно соединять чистыми интерфейсами.