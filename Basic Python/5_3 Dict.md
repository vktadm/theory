**Словарь** — это коллекция, набор элементов, разделённых запятой. Каждый элемент словаря состоит из двух частей, между этими частями ставится двоеточие: первая часть элемента называется **ключ**, вторая часть — **значение**.

**Dict == хэш-таблица**

```python
english = {'рука': 'hand', 'нога': 'leg', 'хвост': 'tail',
		   'питон': 'python', 'бэкенд-разработчик': 'back-end developer'}

english['рука'] # Доступ по ключу
english['рука'] = 'arm' # Присвоение значения
english_values_set = english.values() # Извлечение всех ключей
english_keys_set = english.keys() # Извлечение всех значений
```
Метод values() возвращает **коллекцию** типа dict_values(), а метод keys() — **коллекцию** типа dict_keys(). Это коллекции, похожие на списки; их можно преобразовать в списки или в множества — и работать с ними.
```python
english_values = list(english_values_set)
english_keys = list(english_keys_set)
```
##### Преобразование словаря в список или сет
Преобразовать в множество или в список можно не только коллекцию ключей или значений словаря, но и словарь целиком:
- функция `set(имя_словаря)` преобразует словарь в множество;
- функция `list(имя_словаря)` превратит словарь в список. Но в таких преобразованиях есть особенность: множество или список, которые получатся в результате, будут включать только ключи словаря, а значения будут проигнорированы.
##### Добавление элементов в словарь
```python
# Создаём новый элемент словаря через доступ по ключу.
english['голова'] = 'head'
# Одновременное добавление нескольких элементов.
new_words = {'мозг': 'brain', 'логика': 'logic'} 
english.update(new_words)
```
##### Перебор в цикле `for ... in`
```python
favorite_songs = {'Тополиный пух': 'Иванушки international',
				  'Город золотой': 'Аквариум',
				  'Звезда по имени Солнце': 'Кино',
				  'Space Oddity': 'David Bowie',
				  'Рыба': 'Аквариум',
				  'Серенада Трубадура': 'Муслим Магомаев',} 

# Перебор только по ключу. 
for favorite_song in favorite_songs:     
	print(favorite_song) 

# Перебор по ключу и значению.
for song, performer in favorite_songs.items():
	print('Песню ' + song + ' исполняет ' + performer)
	
# Перебор только значений (values) каждого элемента.
for singer in favorite_songs.values():
	print(singer)

# Перебор только ключей (keys) каждого элемента.
for music in favorite_songs.keys():
	print(music)
```
##### Операции с коллекциями
```python
# Список (list): в квадратных скобках:
sleep_list = ['спать', 'дрыхнуть', 'кемарить', 'спать' ]

# Множество (set): в фигурных скобках, элементы выглядят как в списке,
# но не могут повторяться:
sleep_set = {'дрыхнуть', 'спать', 'кемарить' }

# Словарь (dict): в фигурных скобках, элементы выглядят как ключ:значение;
# ключи не могут повторяться:
sleep_dict = {'спать': 'дрыхнуть', 'почивать': 'кемарить'}

# Есть ли элемент 'дрыхнуть' в списке sleep_list
if 'дрыхнуть' in sleep_list:     
	print('В списке: нашлось!')
else:
	print('В списке: не нашлось :(')
	
# Есть ли элемент 'дрыхнуть' в сете sleep_set?
if 'дрыхнуть' in sleep_set:
	print('В сете: нашлось!')
else:
	print('В сете: не нашлось :(')
	
# Есть ли элемент 'дрыхнуть' в словаре sleep_dict?
if 'дрыхнуть' in sleep_dict:
	print('В словаре: нашлось!')
else:
	print('В словаре: не нашлось :(')
```

В списке и сете нужное слово обнаружилось, а вот в **словаре — нет**. Дело в том, что в работе с оператором in у словарей есть особенность: этот оператор проводит поиск только по ключам, а в словаре sleep_dict слово «дрыхнуть» — это значение элемента, поэтому элемент и не был найден.
```python
forest_list = ['лось', 'коза', 'барсук', 'глухарь', 'лиса', 'ёж']

if 'слонёнок' not in forest_list:
	print('но нету слонёнка в лесу у меня,')
	print('слонёнка весёлого нет!')
```