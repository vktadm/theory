```python
class Book: # Class name
	title = "Title" # Сlass attributes / features (свойства)
	pages = 556 # Сlass attributes

	def set_title(self, title): # Class method
		pass

book_1 = Book() # Object of the class (instance)
book_2 = Book()

book_1.pages = 335 # Local attributes (features) of class object
book_1.title = "New Title"
```
**SOLID** - это набор из пяти принципов объектно-ориентированного программирования (ООП), разработанных Робертом Мартином.

В Python **абстракция** может быть достигнута с помощью **абстрактных классов** и **интерфейсов**. Для создания абстрактных классов используется модуль `abc` (Abstract Base Classes).

**Инкапсуляция** - обеспечивает объединение данных и методов, работающих с этими данными, в единую сущность, называемую классом. Этот механизм позволяет скрывать внутренние детали реализации объекта и предоставляет внешний интерфейс для взаимодействия с ним.

**Наследование** — это один из основных принципов объектно-ориентированного программирования, который позволяет создавать новые классы на основе уже существующих.

**Полиморфизм** - позволяющий объектам разных классов обрабатывать одинаковые команды, реагируя на них по-разному. Слово "полиморфизм" происходит от греческого языка и означает "многообразие форм". 

Полиморфизм позволяет использовать один и тот же интерфейс для работы с разными типами объектов. Это значит, что функции могут принимать объекты различных классов и обрабатывать их, не зная заранее их конкретный тип.

 **Типы полиморфизма**
1. **Полиморфизм подтипов (наследование)**: Это наиболее распространенный вид полиморфизма, который возникает при использовании наследования. Подклассы могут переопределять методы суперкласса, позволяя им реализовывать уникальное поведение при вызове одного и того же метода.
2. **Параметрический полиморфизм**: Этот вид полиморфизма позволяет создавать функции, которые могут работать с любым типом данных. Например, в языках с поддержкой обобщений (generic programming) можно написать одну функцию, которая будет работать с разными типами.
3. **Ad-hoc полиморфизм**: Это перегрузка методов, когда функция может иметь одно имя, но выполнять разные действия в зависимости от типов её аргументов.

## Свойства класса (атрибуты)
```python
class Point:
	"Класс для представления координат точки на плоскости."
	color = 'red'
	circle = 2

type(a) == Point
# >> True
isinstance(a, Point)
# >> True

Point.__doc__ # Вывод описания класса
```
##### Вывод атрибутов класса
```python
Point.__dict__ # Вывести все атрибуты класса
*Point.__dict__ # Распаковка

a.Point() # Экземпляр класса (объект)
a.__dict__ # Вывести все атрибуты экземпляра класса
# >> {}

Point.__dict__['color'] # Вывести атрибут 'color'
```
##### Локальные атрибуты
```python
p.color = 'green' # Локальный атрибут  
p.__dict__
# >> {'color': 'green'}
p.__dict__['color']
# >> green

Point.color
# >> {'color': 'red'}
```
##### Создать атрибут 
**`setattr(class_name, 'attr_name', attr_value)`**

```python
p.quantity = 12 # Создает локальный атрибут
p.__dict__
# >> {'color': 'green', 'quantity': 12}

Point.type_pt = 'type 1' # Создать атрибут класса  
Point.__dict__['type_pt']
# >> type 1

setattr(Point, 'new_atr', 'value') # Создать новый атрибут классса
setattr(Point, 'new_atr', 'new value') # Переопределить атрибут класса

setattr(p, 'local_attr', 'local value') # Создать локальный атрибут классса
setattr(p, 'local_attr', 'new local value') # Переопределить локальный атрибут классса
``` 
###### Получить значение атрибута
**`getattr(class_name, 'attr_name', False)`** - если атрибута не существует вернет False.

```python
getattr(Point, 'not_existing_attr', False) # Получает зн-ие атрибута класса
# >> False

getattr(p, 'local_attr', False) # Получает зн-ие локального атрибута
# >> new local value 
```

##### Удалить атрибут
**`delattr(class_name, 'attr_name')`**

```python
del Point.new_atr # Удалить атрибут класса
delattr(Point, 'type_pt')

del p.local_attr # Удалить локальный атрибут
delattr(p, 'local_attr')
```

##### Проверить, существует ли атрибут
**`hasattr(class_name, 'attr_name')`**

```python
hasattr(Point, 'new_atr') # Проверяет существует ли атрибут класса
hasattr(p, 'new_atr') # Проверяет существует ли локальный атрибут

hasattr(p, 'circle') # в том числе и в атрибутах родителя
```

## Методы класса

**❗️Методы класса являются и атрибутами класса**
##### self
Представляет собой **ссылку на экземпляр класса**, позволяя методам обращаться к атрибутам и другим методам этого экземпляра.

В методах классов `self` обычно указывается как первый параметр. Это позволяет Python автоматически передавать экземпляр класса при вызове метода.

`self` является общепринятой конвенцией, вы можете использовать любое другое имя для этого параметра. Однако рекомендуется использовать именно `self` для повышения читаемости кода.

```python
class Point:  
    color = 'red'  
    circle = 2  
  
    def set_coords(self):  
        print("Вызов метода set_coords")  
  
pt.set_coords()
```
## Магические методы

Общая конструкция: `__name_of_method__()`

##### Инициализатор и финализатор
`__init__(self)`, `__del__(self)`

Инициализатор `__init__`
1. Создание объекта (метод `__new__`)
2. Инициализация объекта (метод `__init__`)

Финализатор `__del__` - срабатывает, когда сборщик мусора удаляет объект из памяти. Пока хоть одна ссылка ведет на объект - сборщик мусора не удаляет