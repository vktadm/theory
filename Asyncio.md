1. **Цикл событий (Event Loop)**. Это центральный элемент асинхронного программирования. Цикл событий управляет корутинами (асинхронными функциями) и отслеживает, какие из них готовы к продолжению выполнения. Это тот самый потенциально бесконечный цикл, который проверяет состояние задач, и переключается между ними по мере необходимости.
    
2. **Корутины (Coroutines).** Это функции, которые могут быть приостановлены и возобновлены в будущем. Они определяются с помощью ключевого слова `async` и вызываются с помощью `await`.
    
3. **IO bound операции (Операции ввода-вывода)**. Это операции, которые требуют ожидания ввода-вывода (чтение файла, сетевые запросы, запросы к СУБД и т.п.). Асинхронное программирование особенно полезно для таких задач, поскольку позволяет обрабатывать другие операции во время ожидания.
    
4. **CPU bound операции (Операции, требовательные к ресурсам центрального процессора)**. Это задачи, ограниченные вычислительной мощностью процессора, например, сложные математические расчёты или обработка больших объёмов данных. Их еще называют "числодробилками". Асинхронное программирование на таких операциях не приносит особой пользы, так как они нагружают процессор и блокируют выполнение других задач.
    
5. **Блокирующий и неблокирующий код.** Блокирующий код останавливает выполнение программы до завершения операции, тогда как неблокирующий позволяет выполнять другие задачи, пока некоторая операция подразумевает ожидание результата.
    
6. **Конкурентность**. Термин, означающий выполнение нескольких задач, через переключение между ними, создавая иллюзию одновременности, в отличие от параллелизма, подразумевающего выполнение нескольких задач, действительно, одновременно на разных ядрах процессора.
## Конкурентный запуск нескольких корутин

Неэффективный код, написанный в асинхронном стиле.

```python
import asyncio
import time


async def send_mail(num):
    print(f'Улетело сообщение {num}')
    await asyncio.sleep(1)  # Имитация отправки сообщения по сети
    print(f'Сообщение {num} доставлено')


async def main():
    for i in range(10):
        await send_mail(i)
    

start_time = time.time()
asyncio.run(main())
print(f'Время выполнения программы: {time.time() - start_time} с')
```

Output:
```bash
Улетело сообщение 0
Сообщение 0 доставлено
Улетело сообщение 1
Сообщение 1 доставлено
Улетело сообщение 2
Сообщение 2 доставлено
Улетело сообщение 3
Сообщение 3 доставлено
Улетело сообщение 4
Сообщение 4 доставлено
Улетело сообщение 5
Сообщение 5 доставлено
Улетело сообщение 6
Сообщение 6 доставлено
Улетело сообщение 7
Сообщение 7 доставлено
Улетело сообщение 8
Сообщение 8 доставлено
Улетело сообщение 9
Сообщение 9 доставлено
Время выполнения программы: 10.011674880981445 с
```

`asyncio.gather` позволяет запускать несколько асинхронных задач "параллельно" и ожидать их завершения, все корутины передаются в цикл событий (**Event Loop**) сразу. Цикл событий обрабатывает их конкурентно, то есть, выполняет часть каждой корутины, переключаясь между ними, как только в одной из них встречается с блокирующей операцией (`await`).

```python
import asyncio  
import time  
  
  
async def send_mail(num):  
    print('Улетело сообщение {}'.format(num))  
    await asyncio.sleep(1)  
    print('Сообщение {} доставлено'.format(num))  
  
  
async def main():  
    tasks = [send_mail(i) for i in range(10)]  
    await asyncio.gather(*tasks)  
  
  
start_time = time.time()  
asyncio.run(main())  
print(f'Время выполнения программы: {time.time() - start_time} с')
```

Output:
```bash
Улетело сообщение 0
Улетело сообщение 1
Улетело сообщение 2
Улетело сообщение 3
Улетело сообщение 4
Улетело сообщение 5
Улетело сообщение 6
Улетело сообщение 7
Улетело сообщение 8
Улетело сообщение 9
Сообщение 0 доставлено
Сообщение 1 доставлено
Сообщение 2 доставлено
Сообщение 3 доставлено
Сообщение 4 доставлено
Сообщение 5 доставлено
Сообщение 6 доставлено
Сообщение 7 доставлено
Сообщение 8 доставлено
Сообщение 9 доставлено
Время выполнения программы: 1.001828908920288 с
```